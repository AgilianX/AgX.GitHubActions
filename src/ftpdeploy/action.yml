name: AgX FTP Deploy
description: "Deploy files using FTP/FTPS protocol"

inputs:
  method:
    type: choice
    description: "Deployment method to use: 'content' (folder) or 'package' (zip archive)"
    options:
      - content
      - package
    default: content
    required: true
  package-path:
    # can omit if deploying from the workspace root (e.g. downloading a build artifact in an empty job)
    # directory example: "publish"  (for folder)
    # archive example: "publish.zip" (for zip)
    description: "Path to the publish directory or zip archive."
    required: false
  server:
    # example: "ftp.mysite.com" or "ftps://ftp.mysite.com"
    description: "FTP server hostname or URL"
    required: true
  port:
    description: "FTP server port (default: 21 for FTP, 990 for FTPS)"
    required: false
    default: "21"
  username:
    description: "Username for FTP authentication"
    required: true
  password:
    description: "Password for FTP authentication"
    required: true
  remote-path:
    description: "Remote directory path on FTP server (e.g., '/', '/wwwroot')"
    required: false
    default: "/"
  protocol:
    type: choice
    description: "FTP protocol to use - defaults to FTP if not specified"
    options:
      - ftp
      - ftps
      - sftp
    default: ftp
    required: false
  passive-mode:
    type: boolean
    description: "Use passive mode for FTP connections"
    default: true
    required: false
  exclude-patterns:
    description: "File patterns to exclude from upload (comma-separated, e.g., '*.log,temp/*')"
    required: false
  verify-ssl:
    type: boolean
    description: "Verify SSL certificates for FTPS connections"
    default: true
    required: false
  clean-target:
    type: boolean
    description: "Clean up old files on the server that are not part of the new deployment"
    default: false
    required: false
  preserve-patterns:
    description: "File patterns to preserve during cleanup (comma-separated, e.g., '*.db,logs/*,config.json')"
    required: false

runs:
  using: "composite"
  steps:
    - name: Analyze path and environment
      shell: pwsh
      run: |
        if ([string]::IsNullOrWhiteSpace("${{ inputs.package-path }}")) {
          $inputPath = "${{ github.workspace }}"
        } else {
          $inputPath = Join-Path "${{ github.workspace }}" "${{ inputs.package-path }}"
        }

        Write-Host "üîç Path analysis:" -ForegroundColor Cyan
        Write-Host "   ‚Ä¢ Workspace: `e[36m${{ github.workspace }}`e[0m"
        Write-Host "   ‚Ä¢ Method: `e[36m${{ inputs.method }}`e[0m"
        Write-Host "   ‚Ä¢ Protocol: `e[36m${{ inputs.protocol }}`e[0m"
        Write-Host "   ‚Ä¢ Server: `e[36m${{ inputs.server }}`e[0m"
        Write-Host "   ‚Ä¢ Port: `e[36m${{ inputs.port }}`e[0m"
        Write-Host "   ‚Ä¢ Remote path: `e[36m${{ inputs.remote-path }}`e[0m"
        Write-Host "   ‚Ä¢ Resolved path: `e[36m$inputPath`e[0m"

        # Store path for subsequent steps
        echo "INPUT_PATH=$inputPath" >> $env:GITHUB_ENV

    - name: Determine deployment source
      shell: pwsh
      run: |
        function Get-PackageSource { param ([string]$InputPath)
            # First check if the specified path exists
            if (Test-Path -Path $InputPath -PathType Leaf) {
                Write-Host "   ‚Ä¢ Package path: `e[36m$InputPath`e[0m"
                Write-Host "   ‚Ä¢ Deployment method: üì¶ `e[36mzip package`e[0m"
                return @{
                    Path = $InputPath
                    Type = "package"
                }
            } else {
                # Try to find a zip file if package input doesn't include .zip extension
                if (-not $InputPath.EndsWith(".zip")) {
                    $possibleZipPath = Join-Path "${{ github.workspace }}" "${{ inputs.package-path }}.zip"
                    if (Test-Path -Path $possibleZipPath -PathType Leaf) {
                        Write-Host "   ‚Ä¢ Found zip package: `e[36m$possibleZipPath`e[0m"
                        Write-Host "   ‚Ä¢ Deployment method: üì¶ `e[36mzip package`e[0m"
                        return @{
                            Path = $possibleZipPath
                            Type = "package"
                        }
                    } else {
                        Write-Host "‚ùå `e[31mPackage file not found at paths:`e[0m"
                        Write-Host "   ‚Ä¢ $InputPath"
                        Write-Host "   ‚Ä¢ $possibleZipPath"
                        exit 1
                    }
                } else {
                    Write-Host "‚ùå `e[31mPackage file not found at path:`e[0m $InputPath"
                    exit 1
                }
            }
        }

        function Get-ContentSource { param ([string]$InputPath)
            if (Test-Path -Path $InputPath -PathType Container) {
                Write-Host "   ‚Ä¢ Content directory: `e[36m$InputPath`e[0m"
                Write-Host "   ‚Ä¢ Deployment method: üìÅ `e[36mdirectory content`e[0m"
                return @{
                    Path = $InputPath
                    Type = "content"
                }
            } else {
                Write-Host "‚ùå `e[31mContent directory not found at path:`e[0m $InputPath"
                exit 1
            }
        }

        Write-Host "üöÄ Starting deployment preparation..." -ForegroundColor Cyan

        $inputPath = $env:INPUT_PATH
        $result = $null

        if ("${{ inputs.method }}" -eq "package") {
            $result = Get-PackageSource -InputPath $inputPath
        } elseif ("${{ inputs.method }}" -eq "content") {
            $result = Get-ContentSource -InputPath $inputPath
        } else {
            Write-Host "‚ùå `e[31mInvalid method. Use '`e[33mpackage`e[31m' for zip archive or '`e[33mcontent`e[31m' for directory.`e[0m"
            exit 1
        }

        # Store values for the deployment step
        echo "SOURCE_PATH=$($result.Path)" >> $env:GITHUB_ENV
        echo "SOURCE_TYPE=$($result.Type)" >> $env:GITHUB_ENV

    - name: Extract package if needed
      shell: pwsh
      run: |
        if ($env:SOURCE_TYPE -eq "package") {
            Write-Host "üì¶ Extracting package for FTP upload..." -ForegroundColor Cyan
            $extractPath = Join-Path $env:TEMP "ftp-extract-$(Get-Date -Format 'yyyyMMddHHmmss')"
            New-Item -ItemType Directory -Path $extractPath -Force | Out-Null

            try {
                Expand-Archive -Path $env:SOURCE_PATH -DestinationPath $extractPath -Force
                Write-Host "   ‚Ä¢ Extracted to: `e[36m$extractPath`e[0m"
                echo "DEPLOY_PATH=$extractPath" >> $env:GITHUB_ENV
            } catch {
                Write-Host "‚ùå `e[31mFailed to extract package:`e[0m $($_.Exception.Message)"
                exit 1
            }
        } else {
            echo "DEPLOY_PATH=$env:SOURCE_PATH" >> $env:GITHUB_ENV
        }

    - name: Install required PowerShell modules
      shell: pwsh
      run: |
        Write-Host "üì• Installing FTP PowerShell modules..." -ForegroundColor Cyan

        # Check if running in a constrained environment
        $policy = Get-ExecutionPolicy
        if ($policy -eq "Restricted") {
            Write-Host "‚ö†Ô∏è  Setting execution policy for current process..." -ForegroundColor Yellow
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process -Force
        }

        try {
            # Try to install/import WinSCP module for better FTP support
            if (-not (Get-Module -ListAvailable -Name "WinSCP" -ErrorAction SilentlyContinue)) {
                Write-Host "   ‚Ä¢ Installing WinSCP PowerShell module..."
                Install-Module -Name WinSCP -Force -Scope CurrentUser -Repository PSGallery
            }
            Import-Module WinSCP -Force
            Write-Host "   ‚Ä¢ ‚úÖ WinSCP module loaded successfully"
            echo "FTP_METHOD=WinSCP" >> $env:GITHUB_ENV
        } catch {
            Write-Host "   ‚Ä¢ ‚ö†Ô∏è  WinSCP module not available, using native .NET FTP client"
            echo "FTP_METHOD=Native" >> $env:GITHUB_ENV
        }

    - name: Execute FTP deployment
      shell: pwsh
      run: |
        Write-Host "üîß Starting FTP deployment..." -ForegroundColor Green

        Write-Host "üîç Environment Variables:" -ForegroundColor Cyan
        Write-Host "   ‚Ä¢ DEPLOY_PATH: `e[36m$env:DEPLOY_PATH`e[0m"
        Write-Host "   ‚Ä¢ SOURCE_PATH: `e[36m$env:SOURCE_PATH`e[0m"
        Write-Host "   ‚Ä¢ SOURCE_TYPE: `e[36m$env:SOURCE_TYPE`e[0m"
        Write-Host "   ‚Ä¢ FTP_METHOD: `e[36m$env:FTP_METHOD`e[0m"

        Write-Host "üîç Input Parameters:" -ForegroundColor Cyan
        Write-Host "   ‚Ä¢ Server: `e[36m${{ inputs.server }}`e[0m"
        Write-Host "   ‚Ä¢ Port: `e[36m${{ inputs.port }}`e[0m"
        Write-Host "   ‚Ä¢ Remote Path: `e[36m${{ inputs.remote-path }}`e[0m"
        Write-Host "   ‚Ä¢ Protocol: `e[36m${{ inputs.protocol }}`e[0m"
        Write-Host "   ‚Ä¢ Passive Mode: `e[36m${{ inputs.passive-mode }}`e[0m"
        Write-Host "   ‚Ä¢ Verify SSL: `e[36m${{ inputs.verify-ssl }}`e[0m"
        Write-Host "   ‚Ä¢ Clean Target: `e[36m${{ inputs.clean-target }}`e[0m"
        Write-Host "   ‚Ä¢ Exclude Patterns: `e[36m${{ inputs.exclude-patterns }}`e[0m"
        Write-Host "   ‚Ä¢ Preserve Patterns: `e[36m${{ inputs.preserve-patterns }}`e[0m"

        $deployPath = $env:DEPLOY_PATH
        $server = "${{ inputs.server }}"
        $port = [int]"${{ inputs.port }}"
        $username = "${{ inputs.username }}"
        $password = "${{ inputs.password }}"
        $remotePath = "${{ inputs.remote-path }}"
        $protocol = "${{ inputs.protocol }}"
        $passiveMode = if ("${{ inputs.passive-mode }}" -eq "true") { $true } else { $false }
        $verifySSL = if ("${{ inputs.verify-ssl }}" -eq "true") { $true } else { $false }
        $excludePatterns = "${{ inputs.exclude-patterns }}"

        # Parse exclude patterns
        Write-Host "üîÑ Processing exclude patterns..."
        try {
            $excludeList = @()
            if (-not [string]::IsNullOrWhiteSpace($excludePatterns)) {
                $excludeList = $excludePatterns -split ',' | ForEach-Object { $_.Trim() }
                Write-Host "   ‚Ä¢ Exclude patterns parsed: `e[36m$($excludeList -join ', ')`e[0m"
                Write-Host "   ‚Ä¢ Exclude list count: `e[36m$($excludeList.Count)`e[0m"
            } else {
                Write-Host "   ‚Ä¢ No exclude patterns specified"
            }
        } catch {
            Write-Host "‚ùå Error parsing exclude patterns: $($_.Exception.Message)" -ForegroundColor Red
            exit 1
        }

        Write-Host "üîÑ Defining helper functions..."
        try {
            function Test-ExcludeFile {
                param([string]$FilePath, [string[]]$Patterns)
                Write-Host "     ‚Ä¢ Testing file: `e[33m$FilePath`e[0m against $($Patterns.Count) patterns" -ForegroundColor DarkGray
                if ($Patterns.Count -eq 0) {
                    Write-Host "     ‚Ä¢ No patterns to check, file not excluded" -ForegroundColor DarkGray
                    return $false
                }

                foreach ($pattern in $Patterns) {
                    Write-Host "     ‚Ä¢ Checking pattern: `e[33m$pattern`e[0m" -ForegroundColor DarkGray
                    if ($FilePath -like $pattern) {
                        Write-Host "     ‚Ä¢ ‚úÖ Pattern matched, file will be excluded" -ForegroundColor DarkGray
                        return $true
                    }
                }
                Write-Host "     ‚Ä¢ ‚ùå No patterns matched, file will be included" -ForegroundColor DarkGray
                return $false
            }
            Write-Host "   ‚Ä¢ Helper function Test-ExcludeFile defined successfully"
        } catch {
            Write-Host "‚ùå Error defining helper functions: $($_.Exception.Message)" -ForegroundColor Red
            exit 1
        }

        Write-Host "üîç Checking FTP method..."
        Write-Host "   ‚Ä¢ FTP_METHOD environment variable: `e[36m$env:FTP_METHOD`e[0m"

        if ($env:FTP_METHOD -eq "WinSCP") {
            Write-Host "üîß Using WinSCP for FTP operations..." -ForegroundColor Cyan

            try {
                Write-Host "üîÑ Creating WinSCP session options..."

                # Create session options
                Write-Host "   ‚Ä¢ Creating SessionOptions object..."
                $sessionOptions = New-Object WinSCP.SessionOptions -Property @{
                    Protocol = switch ($protocol) {
                        "ftp" {
                            Write-Host "   ‚Ä¢ Protocol set to: `e[36mFTP`e[0m"
                            [WinSCP.Protocol]::Ftp
                        }
                        "ftps" {
                            Write-Host "   ‚Ä¢ Protocol set to: `e[36mFTPS`e[0m"
                            [WinSCP.Protocol]::Ftps
                        }
                        "sftp" {
                            Write-Host "   ‚Ä¢ Protocol set to: `e[36mSFTP`e[0m"
                            [WinSCP.Protocol]::Sftp
                        }
                        default {
                            Write-Host "   ‚Ä¢ Protocol defaulted to: `e[36mFTP`e[0m"
                            [WinSCP.Protocol]::Ftp
                        }
                    }
                    HostName = $server
                    PortNumber = $port
                    UserName = $username
                    Password = $password
                }
                Write-Host "üîÑ SessionOptions object created successfully"
                Write-Host "   ‚Ä¢ Hostname: `e[36m$($sessionOptions.HostName)`e[0m"
                Write-Host "   ‚Ä¢ Port: `e[36m$($sessionOptions.PortNumber)`e[0m"
                Write-Host "   ‚Ä¢ Username: `e[36m$($sessionOptions.UserName)`e[0m"
                Write-Host "   ‚Ä¢ Protocol: `e[36m$($sessionOptions.Protocol)`e[0m"

                if ($protocol -eq "ftps") {
                    Write-Host "üîÑ Configuring FTPS settings..."
                    $sessionOptions.FtpSecure = [WinSCP.FtpSecure]::ExplicitSsl
                    Write-Host "   ‚Ä¢ FtpSecure set to: `e[36mExplicitSsl`e[0m"

                    if (-not $verifySSL) {
                        $sessionOptions.GiveUpSecurityAndAcceptAnySslCertificate = $true
                        Write-Host "   ‚Ä¢ SSL certificate verification: `e[33mDisabled`e[0m"
                    } else {
                        Write-Host "   ‚Ä¢ SSL certificate verification: `e[32mEnabled`e[0m"
                    }
                }

                # Create session and connect
                Write-Host "üîÑ Creating WinSCP session..."
                $session = New-Object WinSCP.Session
                Write-Host "   ‚Ä¢ WinSCP Session object created"

                Write-Host "üîÑ Attempting to open connection..."
                $session.Open($sessionOptions)
                Write-Host "   ‚Ä¢ ‚úÖ Connected to FTP server successfully"

                # Test connection
                Write-Host "üîÑ Testing connection..."
                $sessionInfo = $session.SessionInfo
                Write-Host "   ‚Ä¢ Session protocol name: `e[36m$($sessionInfo.ProtocolName)`e[0m"
                Write-Host "   ‚Ä¢ Remote directory: `e[36m$($session.HomePath)`e[0m"

                # Ensure remote directory exists
                Write-Host "üîÑ Verifying remote directory..."
                if (-not [string]::IsNullOrWhiteSpace($remotePath) -and $remotePath -ne "/") {
                    try {
                        Write-Host "   ‚Ä¢ Attempting to create/verify directory: `e[36m$remotePath`e[0m"
                        $session.CreateDirectory($remotePath)
                        Write-Host "   ‚Ä¢ ‚úÖ Created/verified remote directory: `e[36m$remotePath`e[0m"
                    } catch {
                        Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Directory operation result: $($_.Exception.Message)" -ForegroundColor Yellow
                        # Check if directory already exists by trying to list it
                        try {
                            $dirInfo = $session.ListDirectory($remotePath)
                            Write-Host "   ‚Ä¢ ‚úÖ Directory exists and is accessible"
                        } catch {
                            Write-Host "   ‚Ä¢ ‚ùå Directory creation/verification failed: $($_.Exception.Message)" -ForegroundColor Red
                            if ($_.Exception.Message -notlike "*already exists*" -and $_.Exception.Message -notlike "*exist*") {
                                throw
                            }
                        }
                    }
                } else {
                    Write-Host "   ‚Ä¢ Using root directory or default path"
                }

                # Check source directory
                Write-Host "üîÑ Checking source directory..."
                Write-Host "   ‚Ä¢ Deploy path: `e[36m$deployPath`e[0m"
                if (-not (Test-Path -Path $deployPath)) {
                    Write-Host "   ‚Ä¢ ‚ùå Deploy path does not exist!" -ForegroundColor Red
                    throw "Deploy path not found: $deployPath"
                }

                $sourceFiles = Get-ChildItem -Path $deployPath -Recurse -File
                Write-Host "   ‚Ä¢ Found $($sourceFiles.Count) files to process"

                # Upload files
                Write-Host "üîÑ Starting file upload process..."
                $uploadCount = 0
                $skippedCount = 0

                $sourceFiles | ForEach-Object {
                    try {
                        $currentFile = $_
                        Write-Host "üîÑ Processing file: `e[36m$($currentFile.Name)`e[0m" -ForegroundColor DarkGray

                        $relativePath = $currentFile.FullName.Substring($deployPath.Length).TrimStart('\', '/')
                        $relativePath = $relativePath -replace '\\', '/'
                        Write-Host "   ‚Ä¢ Relative path: `e[33m$relativePath`e[0m" -ForegroundColor DarkGray

                        if (Test-ExcludeFile -FilePath $relativePath -Patterns $excludeList) {
                            Write-Host "   ‚Ä¢ ‚è≠Ô∏è  Skipped: `e[33m$relativePath`e[0m (excluded)" -ForegroundColor Yellow
                            $skippedCount++
                            return
                        }

                        $remoteFilePath = if ($remotePath -eq "/" -or [string]::IsNullOrWhiteSpace($remotePath)) {
                            "/$relativePath"
                        } else {
                            "$remotePath/$relativePath"
                        }
                        $remoteFilePath = $remoteFilePath -replace '/+', '/'
                        Write-Host "   ‚Ä¢ Remote file path: `e[33m$remoteFilePath`e[0m" -ForegroundColor DarkGray

                        # Ensure remote directory exists for this file
                        $remoteDir = Split-Path $remoteFilePath -Parent
                        if ($remoteDir -and $remoteDir -ne "/" -and $remoteDir -ne "") {
                            try {
                                Write-Host "   ‚Ä¢ Ensuring remote directory exists: `e[33m$remoteDir`e[0m" -ForegroundColor DarkGray
                                $session.CreateDirectory($remoteDir)
                            } catch {
                                # Ignore if directory already exists
                                Write-Host "   ‚Ä¢ Directory operation: $($_.Exception.Message)" -ForegroundColor DarkGray
                            }
                        }

                        Write-Host "   ‚Ä¢ Uploading: `e[32m$($currentFile.FullName)`e[0m ‚Üí `e[32m$remoteFilePath`e[0m" -ForegroundColor Green
                        $session.PutFiles($currentFile.FullName, $remoteFilePath, $false, $null)
                        Write-Host "   ‚Ä¢ ‚úÖ Uploaded: `e[32m$relativePath`e[0m"
                        $uploadCount++
                    } catch {
                        Write-Host "‚ùå Error uploading file $($currentFile.Name): $($_.Exception.Message)" -ForegroundColor Red
                        Write-Host "‚ùå Error details: $($_.Exception.GetType().FullName)" -ForegroundColor Red
                        Write-Host "‚ùå Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                        throw
                    }
                }

                # Cleanup old files if requested
                $cleanupCount = 0
                if ([bool]"${{ inputs.clean-target }}") {
                    Write-Host "üßπ Starting cleanup of old files..." -ForegroundColor Cyan

                    # Parse preserve patterns
                    $preservePatterns = "${{ inputs.preserve-patterns }}"
                    $preserveList = @()
                    if (-not [string]::IsNullOrWhiteSpace($preservePatterns)) {
                        $preserveList = $preservePatterns -split ',' | ForEach-Object { $_.Trim() }
                        Write-Host "   ‚Ä¢ Preserve patterns: `e[36m$($preserveList -join ', ')`e[0m"
                    }

                    function Test-PreserveFile {
                        param([string]$FilePath, [string[]]$Patterns)
                        if ($Patterns.Count -eq 0) { return $false }

                        foreach ($pattern in $Patterns) {
                            if ($FilePath -like $pattern) {
                                return $true
                            }
                        }
                        return $false
                    }

                    try {
                        # Get list of uploaded files (our new deployment)
                        $uploadedFiles = @()
                        Get-ChildItem -Path $deployPath -Recurse -File | ForEach-Object {
                            $relativePath = $_.FullName.Substring($deployPath.Length).TrimStart('\', '/')
                            $relativePath = $relativePath -replace '\\', '/'

                            if (-not (Test-ExcludeFile -FilePath $relativePath -Patterns $excludeList)) {
                                $uploadedFiles += $relativePath
                            }
                        }

                        # Get list of existing files on server
                        $remoteDirectory = if ([string]::IsNullOrWhiteSpace($remotePath) -or $remotePath -eq "/") { "/" } else { $remotePath }
                        $existingFiles = @()

                        function Get-RemoteFiles {
                            param([string]$Directory, [string]$BasePath = "")

                            try {
                                $items = $session.ListDirectory($Directory)
                                foreach ($item in $items.Files) {
                                    if ($item.Name -eq "." -or $item.Name -eq "..") { continue }

                                    $itemPath = if ($BasePath -eq "") { $item.Name } else { "$BasePath/$($item.Name)" }

                                    if ($item.IsDirectory) {
                                        $subDirPath = if ($Directory -eq "/") { "/$($item.Name)" } else { "$Directory/$($item.Name)" }
                                        Get-RemoteFiles -Directory $subDirPath -BasePath $itemPath
                                    } else {
                                        $existingFiles += $itemPath
                                    }
                                }
                            } catch {
                                Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Could not list directory $Directory : $($_.Exception.Message)"
                            }
                        }

                        Get-RemoteFiles -Directory $remoteDirectory

                        Write-Host "   ‚Ä¢ Found $($existingFiles.Count) existing files on server"
                        Write-Host "   ‚Ä¢ Current deployment contains $($uploadedFiles.Count) files"

                        # Find files to delete (exist on server but not in current deployment)
                        $filesToDelete = @()
                        foreach ($existingFile in $existingFiles) {
                            if ($uploadedFiles -notcontains $existingFile) {
                                if (Test-PreserveFile -FilePath $existingFile -Patterns $preserveList) {
                                    Write-Host "   ‚Ä¢ üîí Preserved: `e[33m$existingFile`e[0m (matches preserve pattern)"
                                } else {
                                    $filesToDelete += $existingFile
                                }
                            }
                        }

                        # Delete old files
                        foreach ($fileToDelete in $filesToDelete) {
                            $remoteFilePath = if ($remoteDirectory -eq "/") { "/$fileToDelete" } else { "$remoteDirectory/$fileToDelete" }
                            $remoteFilePath = $remoteFilePath -replace '/+', '/'

                            try {
                                $session.RemoveFiles($remoteFilePath)
                                Write-Host "   ‚Ä¢ üóëÔ∏è  Deleted: `e[31m$fileToDelete`e[0m"
                                $cleanupCount++
                            } catch {
                                Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Could not delete `e[33m$fileToDelete`e[0m: $($_.Exception.Message)"
                            }
                        }

                        if ($filesToDelete.Count -eq 0) {
                            Write-Host "   ‚Ä¢ ‚úÖ No old files to cleanup"
                        }

                    } catch {
                        Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Cleanup failed: $($_.Exception.Message)" -ForegroundColor Yellow
                        Write-Host "   ‚Ä¢ üì§ Deployment was successful, but cleanup encountered issues"
                    }
                }

                $session.Close()
                Write-Host "üéâ FTP deployment completed successfully!" -ForegroundColor Green
                Write-Host "   ‚Ä¢ Files uploaded: `e[32m$uploadCount`e[0m"
                if ($skippedCount -gt 0) {
                    Write-Host "   ‚Ä¢ Files skipped: `e[33m$skippedCount`e[0m"
                }
                if ($cleanupCount -gt 0) {
                    Write-Host "   ‚Ä¢ Files cleaned up: `e[31m$cleanupCount`e[0m"
                }
            } catch {
                Write-Host "‚ùå FTP deployment failed: $($_.Exception.Message)" -ForegroundColor Red
                Write-Host "‚ùå Error type: $($_.Exception.GetType().FullName)" -ForegroundColor Red
                Write-Host "‚ùå Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                Write-Host "‚ùå Inner exception: $($_.Exception.InnerException.Message)" -ForegroundColor Red
                if ($session -and $session.Opened) {
                    Write-Host "üîÑ Disposing WinSCP session..." -ForegroundColor Yellow
                    $session.Dispose()
                }
                exit 1
            }
        } else {
            Write-Host "üîß Using native .NET FTP client..." -ForegroundColor Cyan
            Write-Host "‚ö†Ô∏è  Note: Native client has limited protocol support (FTP only)" -ForegroundColor Yellow

            Write-Host "üîÑ Validating protocol for native client..."
            if ($protocol -ne "ftp") {
                Write-Host "‚ùå Native .NET client only supports FTP protocol. Please install WinSCP module for FTPS/SFTP support." -ForegroundColor Red
                Write-Host "   ‚Ä¢ Current protocol: `e[36m$protocol`e[0m" -ForegroundColor Red
                exit 1
            }

            try {
                Write-Host "üîÑ Setting up native .NET FTP connection..."

                # Simple FTP upload using .NET FtpWebRequest
                $encodedPath = [System.Uri]::EscapeUriString($remotePath)
                $ftpUri = "ftp://${server}:${port}${encodedPath}"
                Write-Host "   ‚Ä¢ Connecting to: `e[36m$ftpUri`e[0m"
                Write-Host "   ‚Ä¢ Encoded remote path: `e[36m$encodedPath`e[0m"

                # Check source directory
                Write-Host "üîÑ Checking source directory..."
                Write-Host "   ‚Ä¢ Deploy path: `e[36m$deployPath`e[0m"
                if (-not (Test-Path -Path $deployPath)) {
                    Write-Host "   ‚Ä¢ ‚ùå Deploy path does not exist!" -ForegroundColor Red
                    throw "Deploy path not found: $deployPath"
                }

                $sourceFiles = Get-ChildItem -Path $deployPath -Recurse -File
                Write-Host "   ‚Ä¢ Found $($sourceFiles.Count) files to process"

                $uploadCount = 0
                $skippedCount = 0

                $sourceFiles | ForEach-Object {
                    try {
                        $currentFile = $_
                        Write-Host "üîÑ Processing file: `e[36m$($currentFile.Name)`e[0m" -ForegroundColor DarkGray

                        $relativePath = $currentFile.FullName.Substring($deployPath.Length).TrimStart('\', '/')
                        $relativePath = $relativePath -replace '\\', '/'
                        Write-Host "   ‚Ä¢ Relative path: `e[33m$relativePath`e[0m" -ForegroundColor DarkGray

                        if (Test-ExcludeFile -FilePath $relativePath -Patterns $excludeList) {
                            Write-Host "   ‚Ä¢ ‚è≠Ô∏è  Skipped: `e[33m$relativePath`e[0m (excluded)" -ForegroundColor Yellow
                            $skippedCount++
                            return
                        }

                        $remoteFileUri = "$ftpUri/$relativePath" -replace '/+', '/'
                        Write-Host "   ‚Ä¢ Remote URI: `e[33m$remoteFileUri`e[0m" -ForegroundColor DarkGray

                        Write-Host "   ‚Ä¢ Creating FTP request..." -ForegroundColor DarkGray
                        $request = [System.Net.FtpWebRequest]::Create($remoteFileUri)
                        $request.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
                        $request.Credentials = New-Object System.Net.NetworkCredential($username, $password)
                        $request.UsePassive = $passiveMode
                        Write-Host "   ‚Ä¢ FTP request configured (Method: UploadFile, UsePassive: $passiveMode)" -ForegroundColor DarkGray

                        Write-Host "   ‚Ä¢ Reading file content..." -ForegroundColor DarkGray
                        $fileContent = [System.IO.File]::ReadAllBytes($currentFile.FullName)
                        $request.ContentLength = $fileContent.Length
                        Write-Host "   ‚Ä¢ File size: `e[33m$($fileContent.Length) bytes`e[0m" -ForegroundColor DarkGray

                        Write-Host "   ‚Ä¢ Uploading file content..." -ForegroundColor DarkGray
                        $requestStream = $request.GetRequestStream()
                        $requestStream.Write($fileContent, 0, $fileContent.Length)
                        $requestStream.Close()

                        Write-Host "   ‚Ä¢ Getting response..." -ForegroundColor DarkGray
                        $response = $request.GetResponse()
                        Write-Host "   ‚Ä¢ Response status: `e[33m$($response.StatusDescription)`e[0m" -ForegroundColor DarkGray
                        $response.Close()
                        Write-Host "   ‚Ä¢ ‚úÖ Uploaded: `e[32m$relativePath`e[0m"
                        $uploadCount++

                    } catch {
                        Write-Host "‚ùå Error uploading file $($currentFile.Name): $($_.Exception.Message)" -ForegroundColor Red
                        Write-Host "‚ùå Error details: $($_.Exception.GetType().FullName)" -ForegroundColor Red
                        Write-Host "‚ùå Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                        throw
                    }
                }

                # Cleanup old files if requested (Note: Limited functionality with native client)
                $cleanupCount = 0
                if ([bool]"${{ inputs.clean-target }}") {
                    Write-Host "üßπ Starting cleanup of old files..." -ForegroundColor Cyan
                    Write-Host "‚ö†Ô∏è  Note: Cleanup with native .NET client has limited functionality" -ForegroundColor Yellow

                    # Parse preserve patterns
                    $preservePatterns = "${{ inputs.preserve-patterns }}"
                    $preserveList = @()
                    if (-not [string]::IsNullOrWhiteSpace($preservePatterns)) {
                        $preserveList = $preservePatterns -split ',' | ForEach-Object { $_.Trim() }
                        Write-Host "   ‚Ä¢ Preserve patterns: `e[36m$($preserveList -join ', ')`e[0m"
                    }

                    function Test-PreserveFile {
                        param([string]$FilePath, [string[]]$Patterns)
                        if ($Patterns.Count -eq 0) { return $false }

                        foreach ($pattern in $Patterns) {
                            if ($FilePath -like $pattern) {
                                return $true
                            }
                        }
                        return $false
                    }

                    try {
                        # Get list of uploaded files (our new deployment)
                        $uploadedFiles = @()
                        Get-ChildItem -Path $deployPath -Recurse -File | ForEach-Object {
                            $relativePath = $_.FullName.Substring($deployPath.Length).TrimStart('\', '/')
                            $relativePath = $relativePath -replace '\\', '/'

                            if (-not (Test-ExcludeFile -FilePath $relativePath -Patterns $excludeList)) {
                                $uploadedFiles += $relativePath
                            }
                        }

                        # Try to list existing files on server (limited support)
                        try {
                            $listRequest = [System.Net.FtpWebRequest]::Create($ftpUri)
                            $listRequest.Method = [System.Net.WebRequestMethods+Ftp]::ListDirectoryDetails
                            $listRequest.Credentials = New-Object System.Net.NetworkCredential($username, $password)
                            $listRequest.UsePassive = $passiveMode

                            $listResponse = $listRequest.GetResponse()
                            $listStream = $listResponse.GetResponseStream()
                            $reader = New-Object System.IO.StreamReader($listStream)
                            $directoryListing = $reader.ReadToEnd()
                            $reader.Close()
                            $listResponse.Close()

                            $existingFiles = @()
                            $directoryListing -split "`n" | ForEach-Object {
                                $line = $_.Trim()
                                if ($line -and -not $line.StartsWith("d")) {
                                    # Simple parsing - get filename (last part after spaces)
                                    $parts = $line -split '\s+'
                                    if ($parts.Length -gt 0) {
                                        $fileName = $parts[-1]
                                        if ($fileName -and $fileName -ne "." -and $fileName -ne "..") {
                                            $existingFiles += $fileName
                                        }
                                    }
                                }
                            }

                            Write-Host "   ‚Ä¢ Found $($existingFiles.Count) existing files on server"
                            Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Note: Only root-level files can be cleaned with native client"

                            # Find files to delete (exist on server but not in current deployment)
                            $filesToDelete = @()
                            foreach ($existingFile in $existingFiles) {
                                if ($uploadedFiles -notcontains $existingFile) {
                                    if (Test-PreserveFile -FilePath $existingFile -Patterns $preserveList) {
                                        Write-Host "   ‚Ä¢ üîí Preserved: `e[33m$existingFile`e[0m (matches preserve pattern)"
                                    } else {
                                        $filesToDelete += $existingFile
                                    }
                                }
                            }

                            # Delete old files
                            foreach ($fileToDelete in $filesToDelete) {
                                $deleteUri = "$ftpUri/$fileToDelete" -replace '/+', '/'

                                try {
                                    $deleteRequest = [System.Net.FtpWebRequest]::Create($deleteUri)
                                    $deleteRequest.Method = [System.Net.WebRequestMethods+Ftp]::DeleteFile
                                    $deleteRequest.Credentials = New-Object System.Net.NetworkCredential($username, $password)
                                    $deleteRequest.UsePassive = $passiveMode

                                    $deleteResponse = $deleteRequest.GetResponse()
                                    $deleteResponse.Close()

                                    Write-Host "   ‚Ä¢ üóëÔ∏è  Deleted: `e[31m$fileToDelete`e[0m"
                                    $cleanupCount++
                                } catch {
                                    Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Could not delete `e[33m$fileToDelete`e[0m: $($_.Exception.Message)"
                                }
                            }

                            if ($filesToDelete.Count -eq 0) {
                                Write-Host "   ‚Ä¢ ‚úÖ No old files to cleanup"
                            }

                        } catch {
                            Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Could not list server files for cleanup: $($_.Exception.Message)"
                            Write-Host "   ‚Ä¢ üí° Consider using WinSCP module for better cleanup support"
                        }

                    } catch {
                        Write-Host "   ‚Ä¢ ‚ö†Ô∏è  Cleanup failed: $($_.Exception.Message)" -ForegroundColor Yellow
                        Write-Host "   ‚Ä¢ üì§ Deployment was successful, but cleanup encountered issues"
                    }
                }

                Write-Host "üéâ FTP deployment completed successfully!" -ForegroundColor Green
                Write-Host "   ‚Ä¢ Files uploaded: `e[32m$uploadCount`e[0m"
                if ($skippedCount -gt 0) {
                    Write-Host "   ‚Ä¢ Files skipped: `e[33m$skippedCount`e[0m"
                }
                if ($cleanupCount -gt 0) {
                    Write-Host "   ‚Ä¢ Files cleaned up: `e[31m$cleanupCount`e[0m"
                }
            } catch {
                Write-Host "‚ùå FTP deployment failed: $($_.Exception.Message)" -ForegroundColor Red
                Write-Host "‚ùå Error type: $($_.Exception.GetType().FullName)" -ForegroundColor Red
                Write-Host "‚ùå Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
                Write-Host "‚ùå Inner exception: $($_.Exception.InnerException.Message)" -ForegroundColor Red
                exit 1
            }
        }

branding:
  icon: "upload"
  color: "green"
